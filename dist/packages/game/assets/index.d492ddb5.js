import{A as I,S as L,T as R}from"./vendor.a1222a6f.js";const j=function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const t of document.querySelectorAll('link[rel="modulepreload"]'))i(t);new MutationObserver(t=>{for(const r of t)if(r.type==="childList")for(const n of r.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&i(n)}).observe(document,{childList:!0,subtree:!0});function s(t){const r={};return t.integrity&&(r.integrity=t.integrity),t.referrerpolicy&&(r.referrerPolicy=t.referrerpolicy),t.crossorigin==="use-credentials"?r.credentials="include":t.crossorigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function i(t){if(t.ep)return;t.ep=!0;const r=s(t);fetch(t.href,r)}};j();var p=(l=>(l[l.UNDEFINED=0]="UNDEFINED",l[l.GUANINE=3]="GUANINE",l[l.ADENINE=1]="ADENINE",l[l.URACIL=4]="URACIL",l[l.CYTOSINE=2]="CYTOSINE",l[l.CUT=19]="CUT",l))(p||{});const T=class{static pairType(l,e){return T.PAIR_TYPE_MAT[l*8+e]}static stringToNucleotide(l,e=!0,s=!0){if(l==="A"||l==="a")return 1;if(l==="G"||l==="g")return 3;if(l==="U"||l==="u")return 4;if(l==="C"||l==="c")return 2;if(l==="&"||l==="-"||l==="+"){if(e)return 19;throw new Error(`Bad nucleotide '${l}`)}else{if(s)return 0;throw new Error(`Bad nucleotide '${l}`)}}static getColoredLetter(l){return l==="G"?"<G>G</G>":l==="A"?"<A>A</A>":l==="U"?"<U>U</U>":l==="C"?"<C>C</C>":""}static nucleotideToString(l,e=!0,s=!0){if(l===1)return"A";if(l===4)return"U";if(l===3)return"G";if(l===2)return"C";if(l===19){if(e)return"&";throw new Error(`Bad nucleotide '${l}`)}else{if(s)return"?";throw new Error(`Bad nucleotide '${l}`)}}};let C=T;C.PAIR_TYPE_MAT=[1,0,0,0,0,0,0,0,0,0,0,0,5,0,0,5,0,0,0,1,0,0,0,0,0,0,2,0,3,0,0,0,0,6,0,4,0,0,0,6,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0,0,6,0,0,5,0,0,0];class w{constructor(e=[]){this._pairs=[],this._pairs=e.slice()}get length(){return this._pairs.length}get pairs(){return this._pairs}static fromParens(e,s=!1){const i=new w;return i.setPairs(e,s),i}getSatisfiedPairs(e){const s=new Array(this.length);for(let i=0;i<this.length;i++)this.pairs[i]<0?s[i]=-1:this.pairs[i]>i&&(C.pairType(e.nt(i),e.nt(this.pairs[i]))!==0?(s[i]=this.pairs[i],s[this.pairs[i]]=i):(s[i]=-1,s[this.pairs[i]]=-1));return new w(s)}isPaired(e){return this._pairs[e]>=0}pairingPartner(e){return this._pairs[e]}setPairingPartner(e,s){this.isPaired(e)&&this.pairingPartner(e)!==s&&(this._pairs[this.pairingPartner(e)]=-1),this._pairs[e]=s}setUnpaired(e){this._pairs[this._pairs[e]]=-1,this._pairs[e]=-1}nonempty(){return this._pairs.filter(e=>e!==-1).length!==0}isInternal(e){let s=-1,i=-1,t=-1,r=-1;if(this.pairs[e]>=0)return null;let n=e;for(;n>=0;){if(this.pairs[n]>=0){s=n,t=this.pairs[n];break}n--}for(n=e;n<this.pairs.length;){if(this.pairs[n]>=0){i=n,r=this.pairs[n];break}n++}if(s<0||i<0)return null;const a=Math.min(t,r),f=Math.max(t,r);if(s===a)return null;for(let o=a+1;o<f;o++)if(this.pairs[o]>=0)return null;const g=[];for(let o=s;o<=i;o++)g.push(o);for(let o=a;o<=f;o++)g.push(o);return g}getLongestStackLength(){let e=0,s=-1,i=-1;for(let t=0;t<this._pairs.length;t++)this._pairs[t]>t?(s<0&&(s=t),i<0||this._pairs[t]===i-1?i=this._pairs[t]:(s>=0&&t-s>e&&(e=t-s),i=-1,s=-1)):(s>=0&&t-s>e&&(e=t-s),s=-1,i=-1);return e}setPairs(e,s=!1){this._pairs=new Array(e.length).fill(-1);const i=[];for(let t=0;t<e.length;t++)if(e.charAt(t)==="(")i.push(t);else if(e.charAt(t)===")"){if(i.length===0)throw new Error("Invalid parenthesis notation");this._pairs[i[i.length-1]]=t,i.pop()}if(s){for(let t=0;t<e.length;t++)if(e.charAt(t)==="[")i.push(t);else if(e.charAt(t)==="]"){if(i.length===0)throw new Error("Invalid parenthesis notation");this._pairs[i[i.length-1]]=t,i.pop()}for(let t=0;t<e.length;t++)if(e.charAt(t)==="{")i.push(t);else if(e.charAt(t)==="}"){if(i.length===0)throw new Error("Invalid parenthesis notation");this._pairs[i[i.length-1]]=t,i.pop()}for(let t=0;t<e.length;t++)if(e.charAt(t)==="<")i.push(t);else if(e.charAt(t)===">"){if(i.length===0)throw new Error("Invalid parenthesis notation");this._pairs[i[i.length-1]]=t,i.pop()}}for(let t=0;t<this._pairs.length;t++)this._pairs[t]>=0&&(this._pairs[this._pairs[t]]=t)}stems(){const e=[];for(let s=0;s<this.length;++s){const i=this.pairingPartner(s);if(!(s>i)&&this.isPaired(s)){let t=!1;for(const r of e){for(const n of r)if(n[0]===s-1&&n[1]===i+1||n[0]===s+1&&n[1]===i-1||n[1]===s-1&&n[0]===i+1||n[1]===s+1&&n[0]===i-1){r.push([s,i]),t=!0;break}if(t)break}t||e.push([[s,i]])}}return e}stemWith(e){const s=this.stems(),i=this.pairingPartner(e);for(const t of s)for(const r of t)if(r[0]===e&&r[1]===i||r[1]===e&&r[0]===i)return t;return[]}getParenthesis(e=null,s=!1){if(s){const r=new Array(this._pairs.length).fill(-1);for(let h=0;h<this._pairs.length;h++)this._pairs[h]>h&&(r[h]=this._pairs[h],r[this._pairs[h]]=h);const n=[];for(let h=0;h<r.length;++h)r[h]!==-1&&r[h]>h&&n.push([h,r[h]]);const a=[];for(let h=0;h<n.length;++h){let _=!1;for(let c=0;c<a.length;++c){for(let u=0;u<a[c].length;++u)if(n[h][0]-1===a[c][u][0]&&n[h][1]+1===a[c][u][1]||n[h][0]+1===a[c][u][0]&&n[h][1]-1===a[c][u][1]||n[h][0]-1===a[c][u][1]&&n[h][1]+1===a[c][u][0]||n[h][0]+1===a[c][u][1]&&n[h][1]-1===a[c][u][0]){a[c].push(n[h]),_=!0;break}if(_)break}_||a.push([n[h]])}const f=new Array(this._pairs.length).fill("."),g=[/\(/i,/\{/i,/\[/i,/</i],o=[/\)/i,/\}/i,/\]/i,/>/i],d=["(","{","[","<"],m=[")","}","]",">"];if(a.length===0)return f.join("");for(let h=0;h<a.length;++h){const _=a[h];let c=0;const u=f.join("").substring(_[0][0]+1,_[0][1]);for(;u.search(g[c])!==-1&&u.search(o[c])===-1||u.search(g[c])===-1&&u.search(o[c])!==-1;)c+=1;for(let A=0;A<_.length;++A){const y=_[A][0],E=_[A][1];f[y]=d[c],f[E]=m[c]}}return f.join("")}const i=new Array(this._pairs.length).fill(-1);for(let r=0;r<this._pairs.length;r++)this._pairs[r]>r&&(i[r]=this._pairs[r],i[this._pairs[r]]=r);let t="";for(let r=0;r<i.length;r++)i[r]>r?t+="(":i[r]>=0?t+=")":e!=null&&e.hasCut(r)?t+="&":t+=".";return t}filterForPseudoknots(){const e=this.getParenthesis(null,!0).replace(/\{/g,".").replace(/\}/g,".").replace(/\[/g,".").replace(/\]/g,".").replace(/</g,".").replace(/>/g,"."),s=new w;return s.setPairs(e,!1),s}onlyPseudoknots(){const e=this.getParenthesis(null,!0).replace(/\(/g,".").replace(/\)/g,"."),s=new w;return s.setPairs(e,!0),s}numPairs(){let e=0;for(let s=0;s<this._pairs.length;s++)this._pairs[s]>s&&e++;return e}slice(e,s){const i=this._pairs.slice(e,s);for(let t=0;t<i.length;t++)i[t]>=0&&(i[t]-=e);return new w(i)}}class b{constructor(){this.isPair=!1,this.children=[],this.indexA=-1,this.indexB=-1,this.score=0,this.x=0,this.y=0,this.goX=0,this.goY=0}}class k{constructor(e=45,s=45){this._root=null,this._targetPairs=null,this._primarySpace=e,this._pairSpace=s}setupTree(e,s=null){let i=new Array(e.length);this._root=null,this._targetPairs=s,s==null&&(this._targetPairs=e),i.fill(-1);for(let r=0;r<e.length;r++)r<e.pairingPartner(r)&&(i[r]=e.pairingPartner(r),i[e.pairingPartner(r)]=r);this._scoreBiPairs=new Array(i.length+1);for(let r=0;r<i.length;r++)this._scoreBiPairs[r+1]=i[r]+1;this._scoreBiPairs[0]=i.length;let t=!1;for(let r=0;r<i.length;r++)if(i[r]>=0){t=!0;break}if(!!t){i=new w(i).filterForPseudoknots().pairs,this._targetPairs!==null&&(this._targetPairs=this._targetPairs.filterForPseudoknots()),this._root=new b;for(let r=0;r<i.length;r++)if(i[r]>=0)this.addNodesRecursive(i,this._root,r,i[r]),r=i[r];else{const n=new b;n.isPair=!1,n.indexA=r,this._root.children.push(n)}}}getCoords(e){const s=new Array(e),i=new Array(e),t=[Number.MAX_VALUE,Number.MIN_VALUE],r=[Number.MAX_VALUE,Number.MIN_VALUE];if(this._root!=null)this.getCoordsRecursive(this._root,s,i,t,r);else if(s.length<=4){for(let n=0;n<s.length;n++){s[n]=0;const a=n*this._primarySpace;i[n]=a,r[0]=Math.min(r[0],a),r[1]=Math.max(r[1],a)}t[0]=0,t[1]=0}else{let n=(s.length+1)*this._primarySpace+this._pairSpace;const a=n/(2*Math.PI);let f=this._pairSpace/2;const g=0,o=1,d=g*a,m=o*a,h=-o,_=g;for(let c=0;c<s.length;c++){f+=this._primarySpace;const u=f/n*2*Math.PI-Math.PI/2,A=d+Math.cos(u)*h*a+Math.sin(u)*g*a,y=m+Math.cos(u)*_*a+Math.sin(u)*o*a;s[c]=A,i[c]=y,t[0]=Math.min(t[0],A),t[1]=Math.max(t[1],A),r[0]=Math.min(r[0],y),r[1]=Math.max(r[1],y)}}return{xarray:s,yarray:i,xbounds:t,ybounds:r}}drawTree(){this.drawTreeRecursive(this._root,null,0,0,0,1,1)}addNodesRecursive(e,s,i,t){if(i>t)throw new Error(`Error occured while drawing RNA for indices ${i} ${t}`);let r;if(e[i]===t)r=new b,r.isPair=!0,r.indexA=i,r.indexB=t,this.addNodesRecursive(e,r,i+1,t-1);else{r=new b;for(let n=i;n<=t;n++)if(e[n]>=0)this.addNodesRecursive(e,r,n,e[n]),n=e[n];else{const a=new b;a.isPair=!1,a.indexA=n,r.children.push(a)}}s.children.push(r)}getCoordsRecursive(e,s,i,t,r){if(e.isPair){const n=-e.goY*e.rotationDirection,a=e.goX*e.rotationDirection,f=e.x+n*this._pairSpace/2,g=e.x-n*this._pairSpace/2;s[e.indexA]=f,s[e.indexB]=g;const o=e.y+a*this._pairSpace/2,d=e.y-a*this._pairSpace/2;i[e.indexA]=o,i[e.indexB]=d,t[0]=Math.min(t[0],f,g),t[1]=Math.max(t[1],f,g),r[0]=Math.min(r[0],o,d),r[1]=Math.max(r[1],o,d)}else if(e.indexA>=0){const[n,a]=[e.x,e.y];s[e.indexA]=n,i[e.indexA]=a,t[0]=Math.min(t[0],n),t[1]=Math.max(t[1],n),r[0]=Math.min(r[0],a),r[1]=Math.max(r[1],a)}for(const n of e.children)this.getCoordsRecursive(n,s,i,t,r)}getRotationDirectionSign(e){this._root!=null?this.getRotationDirectionSignRecursive(this._root,e):e.fill(1)}getRotationDirectionSignRecursive(e,s){e.isPair?(s[e.indexA]=e.rotationDirection,s[e.indexB]=e.rotationDirection):e.indexA>=0&&(s[e.indexA]=e.rotationDirection);for(const i of e.children)this.getRotationDirectionSignRecursive(i,s)}drawTreeRecursive(e,s,i,t,r,n,a=1){const f=-n*a,g=r*a;let o=0;if(e.goX=r,e.goY=n,e.rotationDirection=a,e.children.length===1)e.x=i,e.y=t,e.children[0].isPair?this.drawTreeRecursive(e.children[0],e,i+r*this._primarySpace,t+n*this._primarySpace,r,n,a):!e.children[0].isPair&&e.children[0].indexA<0?this.drawTreeRecursive(e.children[0],e,i,t,r,n,a):this.drawTreeRecursive(e.children[0],e,i+r*this._primarySpace,t+n*this._primarySpace,r,n,a);else if(e.children.length>1){let d=0;for(let c=0;c<e.children.length;c++)e.children[c].isPair&&d++;let m=(e.children.length+1)*this._primarySpace+(d+1)*this._pairSpace;m+=o;const h=m/(2*Math.PI);let _=this._pairSpace/2;s==null?(e.x=r*h,e.y=n*h):(e.x=s.x+r*h,e.y=s.y+n*h);for(const c of e.children){_+=this._primarySpace,c.isPair&&(_+=this._pairSpace/2);const u=_/m*2*Math.PI-Math.PI/2,A=e.x+Math.cos(u)*f*h+Math.sin(u)*r*h,y=e.y+Math.cos(u)*g*h+Math.sin(u)*n*h,E=A-e.x,N=y-e.y,M=Math.sqrt(E*E+N*N);this.drawTreeRecursive(c,e,A,y,E/M,N/M,a),c.isPair&&(_+=this._pairSpace/2)}}else e.x=i,e.y=t}}class P{constructor(e){this._baseArray=e}hasCut(e,s){return s===void 0&&(s=e),this.baseArray.slice(e,s+1).some(i=>i===p.CUT)}static fromSequenceString(e,s=!0,i=!0){const t=[];for(const r of e)t.push(C.stringToNucleotide(r,s,i));return new P(t)}concat(e){return new P(this._baseArray.concat(e.baseArray))}getColoredSequence(){let e="";const s=this.sequenceString();for(const i of s)e+=C.getColoredLetter(i);return e}getExpColoredSequence(e){if(e==null)return this.sequenceString();const s=e[0],i=Math.max(...e.slice(1)),t=Math.min(...e.slice(1)),r=(i+t)/2;let n="";const a=this.sequenceString();for(let f=0;f<this.length;f++)f<s-1||f>=e.length?n+=a[f]:e[f]<r?n+=`<FONT COLOR='#7777FF'>${a[f]}</FONT>`:n+=`<FONT COLOR='#FF7777'>${a[f]}</FONT>`;return n}countConsecutive(e,s=null){let i=0,t=0,r=-1;for(t=0;t<this._baseArray.length;t++)if(this._baseArray[t]===e)r<0&&(r=t);else if(r>=0){if(i<t-r)if(s==null)i=t-r;else{let n=!0,a;for(a=r;a<t;a++)n=n&&s[a];n===!1&&(i=t-r)}r=-1}return r>=0&&i<t-r&&(i=t-r),i}getRestrictedConsecutive(e,s,i=null){const t=[];let r=0,n=-1;if(s<=0)return t;for(r=0;r<this._baseArray.length;r++)if(this._baseArray[r]===e)n<0&&(n=r);else if(n>=0){if(s<r-n)if(i==null)t.push(n),t.push(r-1);else{let a=!0,f;for(f=n;f<r;f++)a=a&&i[f];a===!1&&(t.push(n),t.push(r-1))}n=-1}return n>=0&&s<r-n&&(t.push(n),t.push(r-1)),t}getSequenceRepetition(e){const s=new Set;let i=0;for(let t=0;t<this.sequenceString.length-e;t++){const r=this.sequenceString().substr(t,e);s.has(r)?i++:s.add(r)}return i++}numGUPairs(e){let s=0;for(let i=0;i<e.length;i++)e.pairingPartner(i)>i&&(this._baseArray[i]===p.GUANINE&&this._baseArray[e.pairingPartner(i)]===p.URACIL&&s++,this._baseArray[i]===p.URACIL&&this._baseArray[e.pairingPartner(i)]===p.GUANINE&&s++);return s}numGCPairs(e){let s=0;for(let i=0;i<e.length;i++)e.pairingPartner(i)>i&&(this._baseArray[i]===p.GUANINE&&this._baseArray[e.pairingPartner(i)]===p.CYTOSINE&&s++,this._baseArray[i]===p.CYTOSINE&&this._baseArray[e.pairingPartner(i)]===p.GUANINE&&s++);return s}numUAPairs(e){let s=0;for(let i=0;i<e.length;i++)e.pairingPartner(i)>i&&(this._baseArray[i]===p.ADENINE&&this._baseArray[e.pairingPartner(i)]===p.URACIL&&s++,this._baseArray[i]===p.URACIL&&this._baseArray[e.pairingPartner(i)]===p.ADENINE&&s++);return s}count(e){return this._baseArray.reduce((s,i)=>s+(i===e?1:0),0)}findCut(e=0){return this._baseArray.indexOf(p.CUT,e)}findUndefined(){return this._baseArray.indexOf(p.UNDEFINED)}lastCut(){return this._baseArray.lastIndexOf(p.CUT)}get baseArray(){return this._baseArray}set baseArray(e){this._baseArray=e}nt(e){return this._baseArray[e]}setNt(e,s){this._baseArray[e]=s}sequenceString(e=!0,s=!0){return this._baseArray.map(i=>C.nucleotideToString(i,e,s)).join("")}toString(){return this.sequenceString()}get length(){return this._baseArray.length}slice(e,s=-1){return s===-1?new P(this._baseArray.slice(e)):new P(this._baseArray.slice(e,s))}}function x(){const l=new k(45,45);l.setupTree(new w([-1,13,12,11,10,9,-1,-1,-1,-1,-1,-1,-1,-1,-1])),l.drawTree();const e=new P([2,1,2,3,4,1,1,1,1,4,3,2,3,4,1]),s=l.getCoords(e.length),{xarray:i,yarray:t}=s;console.log({xarray:i,yarray:t})}const S=new I({resolution:devicePixelRatio});document.body.appendChild(S.view);window.addEventListener("resize",U);function U(){S.renderer.resize(window.innerWidth,window.innerHeight)}U();const O=new L(R.from("assets/new_big_blue.png"));S.stage.addChild(O);x();
